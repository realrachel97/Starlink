{"ast":null,"code":"var epsilon = 1e-4,\n    epsilonInverse = 1e4,\n    x0 = -180,\n    x0e = x0 + epsilon,\n    x1 = 180,\n    x1e = x1 - epsilon,\n    y0 = -90,\n    y0e = y0 + epsilon,\n    y1 = 90,\n    y1e = y1 - epsilon;\n\nfunction nonempty(coordinates) {\n  return coordinates.length > 0;\n}\n\nfunction quantize(x) {\n  return Math.floor(x * epsilonInverse) / epsilonInverse;\n}\n\nfunction normalizePoint(y) {\n  return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)]; // pole or antimeridian?\n}\n\nfunction clampPoint(p) {\n  var x = p[0],\n      y = p[1],\n      clamped = false;\n  if (x <= x0e) x = x0, clamped = true;else if (x >= x1e) x = x1, clamped = true;\n  if (y <= y0e) y = y0, clamped = true;else if (y >= y1e) y = y1, clamped = true;\n  return clamped ? [x, y] : p;\n}\n\nfunction clampPoints(points) {\n  return points.map(clampPoint);\n} // For each ring, detect where it crosses the antimeridian or pole.\n\n\nfunction extractFragments(rings, polygon, fragments) {\n  for (var j = 0, m = rings.length; j < m; ++j) {\n    var ring = rings[j].slice(); // By default, assume that this ring doesn’t need any stitching.\n\n    fragments.push({\n      index: -1,\n      polygon: polygon,\n      ring: ring\n    });\n\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      var point = ring[i],\n          x = point[0],\n          y = point[1]; // If this is an antimeridian or polar point…\n\n      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n        ring[i] = clampPoint(point); // Advance through any antimeridian or polar points…\n\n        for (var k = i + 1; k < n; ++k) {\n          var pointk = ring[k],\n              xk = pointk[0],\n              yk = pointk[1];\n          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;\n        } // If this was just a single antimeridian or polar point,\n        // we don’t need to cut this ring into a fragment;\n        // we can just leave it as-is.\n\n\n        if (k === i + 1) continue; // Otherwise, if this is not the first point in the ring,\n        // cut the current fragment so that it ends at the current point.\n        // The current point is also normalized for later joining.\n\n        if (i) {\n          var fragmentBefore = {\n            index: -1,\n            polygon: polygon,\n            ring: ring.slice(0, i + 1)\n          };\n          fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);\n          fragments[fragments.length - 1] = fragmentBefore;\n        } // If the ring started with an antimeridian fragment,\n        // we can ignore that fragment entirely.\n        else fragments.pop(); // If the remainder of the ring is an antimeridian fragment,\n        // move on to the next ring.\n\n\n        if (k >= n) break; // Otherwise, add the remaining ring fragment and continue.\n\n        fragments.push({\n          index: -1,\n          polygon: polygon,\n          ring: ring = ring.slice(k - 1)\n        });\n        ring[0] = normalizePoint(ring[0][1]);\n        i = -1;\n        n = ring.length;\n      }\n    }\n  }\n} // Now stitch the fragments back together into rings.\n\n\nfunction stitchFragments(fragments) {\n  var i,\n      n = fragments.length; // To connect the fragments start-to-end, create a simple index by end.\n\n  var fragmentByStart = {},\n      fragmentByEnd = {},\n      fragment,\n      start,\n      startFragment,\n      end,\n      endFragment; // For each fragment…\n\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    start = fragment.ring[0];\n    end = fragment.ring[fragment.ring.length - 1]; // If this fragment is closed, add it as a standalone ring.\n\n    if (start[0] === end[0] && start[1] === end[1]) {\n      fragment.polygon.push(fragment.ring);\n      fragments[i] = null;\n      continue;\n    }\n\n    fragment.index = i;\n    fragmentByStart[start] = fragmentByEnd[end] = fragment;\n  } // For each open fragment…\n\n\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n\n    if (fragment) {\n      start = fragment.ring[0];\n      end = fragment.ring[fragment.ring.length - 1];\n      startFragment = fragmentByEnd[start];\n      endFragment = fragmentByStart[end];\n      delete fragmentByStart[start];\n      delete fragmentByEnd[end]; // If this fragment is closed, add it as a standalone ring.\n\n      if (start[0] === end[0] && start[1] === end[1]) {\n        fragment.polygon.push(fragment.ring);\n        continue;\n      }\n\n      if (startFragment) {\n        delete fragmentByEnd[start];\n        delete fragmentByStart[startFragment.ring[0]];\n        startFragment.ring.pop(); // drop the shared coordinate\n\n        fragments[startFragment.index] = null;\n        fragment = {\n          index: -1,\n          polygon: startFragment.polygon,\n          ring: startFragment.ring.concat(fragment.ring)\n        };\n\n        if (startFragment === endFragment) {\n          // Connect both ends to this single fragment to create a ring.\n          fragment.polygon.push(fragment.ring);\n        } else {\n          fragment.index = n++;\n          fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n        }\n      } else if (endFragment) {\n        delete fragmentByStart[end];\n        delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];\n        fragment.ring.pop(); // drop the shared coordinate\n\n        fragment = {\n          index: n++,\n          polygon: endFragment.polygon,\n          ring: fragment.ring.concat(endFragment.ring)\n        };\n        fragments[endFragment.index] = null;\n        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n      } else {\n        fragment.ring.push(fragment.ring[0]); // close ring\n\n        fragment.polygon.push(fragment.ring);\n      }\n    }\n  }\n}\n\nfunction stitchFeature(input) {\n  var output = {\n    type: \"Feature\",\n    geometry: stitchGeometry(input.geometry)\n  };\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  if (input.properties != null) output.properties = input.properties;\n  return output;\n}\n\nfunction stitchGeometry(input) {\n  if (input == null) return input;\n  var output, fragments, i, n;\n\n  switch (input.type) {\n    case \"GeometryCollection\":\n      output = {\n        type: \"GeometryCollection\",\n        geometries: input.geometries.map(stitchGeometry)\n      };\n      break;\n\n    case \"Point\":\n      output = {\n        type: \"Point\",\n        coordinates: clampPoint(input.coordinates)\n      };\n      break;\n\n    case \"MultiPoint\":\n    case \"LineString\":\n      output = {\n        type: input.type,\n        coordinates: clampPoints(input.coordinates)\n      };\n      break;\n\n    case \"MultiLineString\":\n      output = {\n        type: \"MultiLineString\",\n        coordinates: input.coordinates.map(clampPoints)\n      };\n      break;\n\n    case \"Polygon\":\n      {\n        var polygon = [];\n        extractFragments(input.coordinates, polygon, fragments = []);\n        stitchFragments(fragments);\n        output = {\n          type: \"Polygon\",\n          coordinates: polygon\n        };\n        break;\n      }\n\n    case \"MultiPolygon\":\n      {\n        fragments = [], i = -1, n = input.coordinates.length;\n        var polygons = new Array(n);\n\n        while (++i < n) extractFragments(input.coordinates[i], polygons[i] = [], fragments);\n\n        stitchFragments(fragments);\n        output = {\n          type: \"MultiPolygon\",\n          coordinates: polygons.filter(nonempty)\n        };\n        break;\n      }\n\n    default:\n      return input;\n  }\n\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nexport default function (input) {\n  if (input == null) return input;\n\n  switch (input.type) {\n    case \"Feature\":\n      return stitchFeature(input);\n\n    case \"FeatureCollection\":\n      {\n        var output = {\n          type: \"FeatureCollection\",\n          features: input.features.map(stitchFeature)\n        };\n        if (input.bbox != null) output.bbox = input.bbox;\n        return output;\n      }\n\n    default:\n      return stitchGeometry(input);\n  }\n}","map":{"version":3,"names":["epsilon","epsilonInverse","x0","x0e","x1","x1e","y0","y0e","y1","y1e","nonempty","coordinates","length","quantize","x","Math","floor","normalizePoint","y","clampPoint","p","clamped","clampPoints","points","map","extractFragments","rings","polygon","fragments","j","m","ring","slice","push","index","i","n","point","k","pointk","xk","yk","fragmentBefore","pop","stitchFragments","fragmentByStart","fragmentByEnd","fragment","start","startFragment","end","endFragment","concat","stitchFeature","input","output","type","geometry","stitchGeometry","id","bbox","properties","geometries","polygons","Array","filter","features"],"sources":["D:/LaiOfferProjects/starlink/starlink/node_modules/d3-geo-projection/src/stitch.js"],"sourcesContent":["var epsilon = 1e-4,\n    epsilonInverse = 1e4,\n    x0 = -180, x0e = x0 + epsilon,\n    x1 = 180, x1e = x1 - epsilon,\n    y0 = -90, y0e = y0 + epsilon,\n    y1 = 90, y1e = y1 - epsilon;\n\nfunction nonempty(coordinates) {\n  return coordinates.length > 0;\n}\n\nfunction quantize(x) {\n  return Math.floor(x * epsilonInverse) / epsilonInverse;\n}\n\nfunction normalizePoint(y) {\n  return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)]; // pole or antimeridian?\n}\n\nfunction clampPoint(p) {\n  var x = p[0], y = p[1], clamped = false;\n  if (x <= x0e) x = x0, clamped = true;\n  else if (x >= x1e) x = x1, clamped = true;\n  if (y <= y0e) y = y0, clamped = true;\n  else if (y >= y1e) y = y1, clamped = true;\n  return clamped ? [x, y] : p;\n}\n\nfunction clampPoints(points) {\n  return points.map(clampPoint);\n}\n\n// For each ring, detect where it crosses the antimeridian or pole.\nfunction extractFragments(rings, polygon, fragments) {\n  for (var j = 0, m = rings.length; j < m; ++j) {\n    var ring = rings[j].slice();\n\n    // By default, assume that this ring doesn’t need any stitching.\n    fragments.push({index: -1, polygon: polygon, ring: ring});\n\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      var point = ring[i],\n          x = point[0],\n          y = point[1];\n\n      // If this is an antimeridian or polar point…\n      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n        ring[i] = clampPoint(point);\n\n        // Advance through any antimeridian or polar points…\n        for (var k = i + 1; k < n; ++k) {\n          var pointk = ring[k],\n              xk = pointk[0],\n              yk = pointk[1];\n          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;\n        }\n\n        // If this was just a single antimeridian or polar point,\n        // we don’t need to cut this ring into a fragment;\n        // we can just leave it as-is.\n        if (k === i + 1) continue;\n\n        // Otherwise, if this is not the first point in the ring,\n        // cut the current fragment so that it ends at the current point.\n        // The current point is also normalized for later joining.\n        if (i) {\n          var fragmentBefore = {index: -1, polygon: polygon, ring: ring.slice(0, i + 1)};\n          fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);\n          fragments[fragments.length - 1] = fragmentBefore;\n        }\n\n        // If the ring started with an antimeridian fragment,\n        // we can ignore that fragment entirely.\n        else fragments.pop();\n\n        // If the remainder of the ring is an antimeridian fragment,\n        // move on to the next ring.\n        if (k >= n) break;\n\n        // Otherwise, add the remaining ring fragment and continue.\n        fragments.push({index: -1, polygon: polygon, ring: ring = ring.slice(k - 1)});\n        ring[0] = normalizePoint(ring[0][1]);\n        i = -1;\n        n = ring.length;\n      }\n    }\n  }\n}\n\n// Now stitch the fragments back together into rings.\nfunction stitchFragments(fragments) {\n  var i, n = fragments.length;\n\n  // To connect the fragments start-to-end, create a simple index by end.\n  var fragmentByStart = {},\n      fragmentByEnd = {},\n      fragment,\n      start,\n      startFragment,\n      end,\n      endFragment;\n\n  // For each fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    start = fragment.ring[0];\n    end = fragment.ring[fragment.ring.length - 1];\n\n    // If this fragment is closed, add it as a standalone ring.\n    if (start[0] === end[0] && start[1] === end[1]) {\n      fragment.polygon.push(fragment.ring);\n      fragments[i] = null;\n      continue;\n    }\n\n    fragment.index = i;\n    fragmentByStart[start] = fragmentByEnd[end] = fragment;\n  }\n\n  // For each open fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    if (fragment) {\n      start = fragment.ring[0];\n      end = fragment.ring[fragment.ring.length - 1];\n      startFragment = fragmentByEnd[start];\n      endFragment = fragmentByStart[end];\n\n      delete fragmentByStart[start];\n      delete fragmentByEnd[end];\n\n      // If this fragment is closed, add it as a standalone ring.\n      if (start[0] === end[0] && start[1] === end[1]) {\n        fragment.polygon.push(fragment.ring);\n        continue;\n      }\n\n      if (startFragment) {\n        delete fragmentByEnd[start];\n        delete fragmentByStart[startFragment.ring[0]];\n        startFragment.ring.pop(); // drop the shared coordinate\n        fragments[startFragment.index] = null;\n        fragment = {index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring)};\n\n        if (startFragment === endFragment) {\n          // Connect both ends to this single fragment to create a ring.\n          fragment.polygon.push(fragment.ring);\n        } else {\n          fragment.index = n++;\n          fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n        }\n      } else if (endFragment) {\n        delete fragmentByStart[end];\n        delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];\n        fragment.ring.pop(); // drop the shared coordinate\n        fragment = {index: n++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring)};\n        fragments[endFragment.index] = null;\n        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n      } else {\n        fragment.ring.push(fragment.ring[0]); // close ring\n        fragment.polygon.push(fragment.ring);\n      }\n    }\n  }\n}\n\nfunction stitchFeature(input) {\n  var output = {type: \"Feature\", geometry: stitchGeometry(input.geometry)};\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  if (input.properties != null) output.properties = input.properties;\n  return output;\n}\n\nfunction stitchGeometry(input) {\n  if (input == null) return input;\n  var output, fragments, i, n;\n  switch (input.type) {\n    case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(stitchGeometry)}; break;\n    case \"Point\": output = {type: \"Point\", coordinates: clampPoint(input.coordinates)}; break;\n    case \"MultiPoint\": case \"LineString\": output = {type: input.type, coordinates: clampPoints(input.coordinates)}; break;\n    case \"MultiLineString\": output = {type: \"MultiLineString\", coordinates: input.coordinates.map(clampPoints)}; break;\n    case \"Polygon\": {\n      var polygon = [];\n      extractFragments(input.coordinates, polygon, fragments = []);\n      stitchFragments(fragments);\n      output = {type: \"Polygon\", coordinates: polygon};\n      break;\n    }\n    case \"MultiPolygon\": {\n      fragments = [], i = -1, n = input.coordinates.length;\n      var polygons = new Array(n);\n      while (++i < n) extractFragments(input.coordinates[i], polygons[i] = [], fragments);\n      stitchFragments(fragments);\n      output = {type: \"MultiPolygon\", coordinates: polygons.filter(nonempty)};\n      break;\n    }\n    default: return input;\n  }\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nexport default function(input) {\n  if (input == null) return input;\n  switch (input.type) {\n    case \"Feature\": return stitchFeature(input);\n    case \"FeatureCollection\": {\n      var output = {type: \"FeatureCollection\", features: input.features.map(stitchFeature)};\n      if (input.bbox != null) output.bbox = input.bbox;\n      return output;\n    }\n    default: return stitchGeometry(input);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}